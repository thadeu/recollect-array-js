import t from"lodash.filter";import r from"lodash.last";import n from"lodash.chunk";import e from"lodash.isplainobject";import s from"lodash.isfunction";import i from"lodash.get";const c=(t,r,n)=>i(t,r)==n,o=(t,r,n)=>{const e=i(t,r);return n.match(/^([^*])(\w*)([*])$/)?e.startsWith(n.replace(/\*$/,"")):n.match(/^([*])(\w*)([^*])$/)?e.endsWith(n.replace(/^\*/,"")):!!n.match(/^\*\w*\*$/)&&e.includes(n.replace(/^\*/,"").replace(/\*$/,""))};class a{static factory(t,r,n){if(this.PREDICATES.includes(t)&&this[t])return s(n)&&(n=n()),this[t](r,n)}static matches(t,r){return function(n){let e=[i(n,t)].flatMap(t=>t);return(r=[r].flatMap(t=>t)).some(t=>e.includes(t))}}static not_matches(t,r){return!this.matches(t,r)}static in(t,r){return this.matches(t,r)}static not_in(t,r){return!this.in(t,r)}static eq(t,r){return function(n){return c(n,t,r)}}static not_eq(t,r){return function(n){return!c(n,t,r)}}static gte(t,r){return function(n){return i(n,t)>=r}}static gt(t,r){return function(n){return i(n,t)>r}}static lte(t,r){return function(n){return i(n,t)<=r}}static lt(t,r){return function(n){return i(n,t)<r}}static cont(t,r){return function(n){return o(n,t,r)}}static not_cont(t,r){return function(n){return!o(n,t,r)}}static starts_with(t,r){return function(n){return o(n,t,`${r}*`)}}static st(t,r){return function(n){return this.starts_with(n,t,r)}}static not_st(t,r){return function(n){return!this.starts_with(n,t,r)}}}a.PREDICATES=["eq","not_eq","gte","lte","gt","lt","matches","not_matches","in","not_in","cont","not_cont","starts_with","not_starts_with","st","not_st"];const u=(r,n,e,s)=>t(r,a.factory(n,e,s)),l=(t,r,n)=>{for(let[e,s]of Object.entries(n))t=u(t,e,r,s);return t},f=(t,n,e)=>{let s=n.split("_"),i=r(s),c=n.replace(`_${i}`,"");return u(t,i,c,e)};class h{static filter(t,r){let n=Array.from(t);return n=this.recollect(n,r),n}}h.recollect=(t,r)=>{let s=Object.entries(r).flatMap(t=>t),i=n(s,2);for(let[n,s]of i)t=e(s)?l(t,n,s):f(t,n,r[n]);return t};export{h as RecollectArray,h as default};
//# sourceMappingURL=index.modern.mjs.map
