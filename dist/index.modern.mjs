import t from"lodash.filter";import r from"lodash.last";import e from"lodash.chunk";import n from"lodash.isplainobject";import s from"lodash.isfunction";import i from"lodash.get";const c=(t,r,e)=>i(t,r)==e,o=(t,r,e)=>{const n=i(t,r);return e.match(/^([^*])(\w*)([*])$/)?n.startsWith(e.replace(/\*$/,"")):e.match(/^([*])(\w*)([^*])$/)?n.endsWith(e.replace(/^\*/,"")):!!e.match(/^\*\w*\*$/)&&n.includes(e.replace(/^\*/,"").replace(/\*$/,""))};class a{static factory(t,r,e){if(this.PREDICATES.includes(t)&&this[t])return s(e)&&(e=e()),this[t](r,e)}static matches(t,r){return function(e){let n=[i(e,t)].flatMap(t=>t);return(r=[r].flatMap(t=>t)).some(t=>n.includes(t))}}static not_matches(t,r){return!this.matches(t,r)}static exists(t,r){return e=>"true"==String(r)?this.not_in(t,["",null,void 0])(e):this.in(t,["",null,void 0])(e)}static not_exists(t,r){return r=>this.exists(t,!1)(r)}static ex(t,r){return r=>this.exists(t,!0)(r)}static not_ex(t,r){return r=>this.exists(t,!1)(r)}static in(t,r){return e=>this.matches(t,r)(e)}static not_in(t,r){return e=>!this.matches(t,r)(e)}static eq(t,r){return function(e){return c(e,t,r)}}static not_eq(t,r){return function(e){return!c(e,t,r)}}static gte(t,r){return function(e){return i(e,t)>=r}}static gt(t,r){return function(e){return i(e,t)>r}}static lte(t,r){return function(e){return i(e,t)<=r}}static lt(t,r){return function(e){return i(e,t)<r}}static cont(t,r){return function(e){return o(e,t,r)}}static not_cont(t,r){return function(e){return!o(e,t,r)}}static starts_with(t,r){return function(e){return o(e,t,`${r}*`)}}static st(t,r){return this.starts_with(t,r)}static not_st(t,r){return!this.starts_with(t,r)}}a.PREDICATES=["eq","not_eq","gte","lte","gt","lt","matches","not_matches","in","not_in","cont","not_cont","starts_with","not_starts_with","st","not_st","exists","not_exists","ex","not_ex"];const u=(r,e,n,s)=>t(r,a.factory(e,n,s)),l=(t,r,e)=>{for(let[n,s]of Object.entries(e))t=u(t,n,r,s);return t},h=(t,e,n)=>{let s=e.split("_"),i=r(s),c=e.replace(`_${i}`,"");return u(t,i,c,n)};class f{static filter(t,r){let e=Array.from(t);return e=this.recollect(e,r),e}}f.recollect=(t,r)=>{let s=Object.entries(r).flatMap(t=>t),i=e(s,2);for(let[e,s]of i)t=n(s)?l(t,e,s):h(t,e,r[e]);return t};export{f as RecollectArray,f as default};
//# sourceMappingURL=index.modern.mjs.map
