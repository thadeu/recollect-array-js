{"version":3,"file":"index.modern.mjs","sources":["../src/predicates.ts","../src/utils.ts","../src/recollect-array.ts"],"sourcesContent":["import isFunction from 'lodash.isfunction'\nimport get from 'lodash.get'\n\nconst equals = (data, field, value) => get(data, field) == value\n\nconst contains = (data, field, value) => {\n  const target = get(data, field)\n\n  let startRegex = /^([^*])(\\w*)([*])$/\n  let endRegex = /^([*])(\\w*)([^*])$/\n  let includeRegex = /^\\*\\w*\\*$/\n\n  if (value.match(startRegex)) {\n    return String(target).startsWith(value.replace(/\\*$/, ''))\n  } else if (value.match(endRegex)) {\n    return String(target).endsWith(value.replace(/^\\*/, ''))\n  } else if (value.match(includeRegex)) {\n    return String(target).includes(value.replace(/^\\*/, '').replace(/\\*$/, ''))\n  } else {\n    return false\n  }\n}\n\nexport class Predicate {\n  static PREDICATES = [\n    'eq',\n    'not_eq',\n    'gte',\n    'lte',\n    'gt',\n    'lt',\n    'matches',\n    'not_matches',\n    'in',\n    'not_in',\n    'cont',\n    'not_cont',\n    'starts_with',\n    'not_starts_with',\n    'st',\n    'not_st',\n    'exists',\n    'not_exists',\n    'ex',\n    'not_ex',\n    'len',\n    'regex',\n    'not_regex',\n    'reg',\n    'not_reg',\n    'empty'\n  ]\n\n  static factory(predicate, field, value) {\n    if (!this.PREDICATES.includes(predicate)) return undefined\n    if (!this[predicate]) return undefined\n\n    if (isFunction(value)) {\n      value = value()\n    }\n\n    return this[predicate](field, value)\n  }\n\n  static empty(field, value) {\n    return function (data) {\n      let target = get(data, field)\n      let flags = [null, undefined, NaN, '', ' ']\n\n      if (value) {\n        return flags.includes(target)\n      }\n\n      return !flags.includes(target)\n    }\n  }\n\n  static len(field, value) {\n    return function (data) {\n      let target = get(data, field)\n      return value > String(target).length\n    }\n  }\n\n  static regex(field, value) {\n    return function(data) {\n      let target = get(data, field)\n      let reg = new RegExp(value, 'g')\n\n      return reg.test(target)\n    }\n  }\n\n  static reg(field, value) {\n    return this.regex(field, value)\n  }\n\n  static not_reg(field, value) {\n    return !this.regex(field, value)\n  }\n\n  static not_regex(field, value) {\n    return !this.regex(field, value)\n  }\n\n  static matches(field, value) {\n    return function (data) {\n      let target = [get(data, field)].flatMap((o) => o)\n      value = [value].flatMap((o) => o)\n\n      return value.some((o: any) => target.includes(o))\n    }\n  }\n\n  static not_matches(field, value) {\n    return !this.matches(field, value)\n  }\n\n  static exists(field, value) {\n    return (data) => {\n      if (String(value) == 'true') {\n        return this.not_in(field, ['', null, undefined])(data)\n      } else {\n        return this.in(field, ['', null, undefined])(data)\n      }\n    }\n  }\n\n  static not_exists(field, value) {\n    return (data) => {\n      return this.exists(field, false)(data)\n    }\n  }\n\n  static ex(field, value) {\n    return (data) => {\n      return this.exists(field, true)(data)\n    }\n  }\n\n  static not_ex(field, value) {\n    return (data) => {\n      return this.exists(field, false)(data)\n    }\n  }\n\n  static in(field, value) {\n    return (data) => {\n      return this.matches(field, value)(data)\n    }\n  }\n\n  static not_in(field, value) {\n    return (data) => {\n      return !this.matches(field, value)(data)\n    }\n  }\n\n  static eq(field, value) {\n    return function (data) {\n      return equals(data, field, value)\n    }\n  }\n\n  static not_eq(field, value) {\n    return function (data) {\n      return !equals(data, field, value)\n    }\n  }\n\n  static gte(field, value) {\n    return function (data) {\n      const target = Number(get(data, field))\n\n      return target >= value\n    }\n  }\n\n  static gt(field, value) {\n    return function (data) {\n      const target = Number(get(data, field))\n\n      return target > value\n    }\n  }\n\n  static lte(field, value) {\n    return function (data) {\n      const target = Number(get(data, field))\n\n      return target <= value\n    }\n  }\n\n  static lt(field, value) {\n    return function (data) {\n      const target = Number(get(data, field))\n\n      return target < value\n    }\n  }\n\n  static cont(field, value) {\n    return function (data) {\n      return contains(data, field, value)\n    }\n  }\n\n  static not_cont(field, value) {\n    return function (data) {\n      return !contains(data, field, value)\n    }\n  }\n\n  static starts_with(field, value) {\n    return function(data) {\n      return contains(data, field, `${value}*`)\n    }\n  }\n\n  static not_starts_with(field, value) {\n    return function(data) {\n      return !contains(data, field, `${value}*`)\n    }\n  }\n\n  static st(field, value) {\n    return function(data) {\n      return contains(data, field, `${value}*`)\n    }\n  }\n\n  static not_st(field, value) {\n    return function(data) {\n      return !contains(data, field, `${value}*`)\n    }\n  }\n}\n\nexport default Predicate\n","import filter from 'lodash.filter'\nimport last from 'lodash.last'\nimport chunk from 'lodash.chunk'\nimport isPlainObject from 'lodash.isplainobject'\n\nimport Predicate from '@/predicates'\n\nexport { isPlainObject }\n\nexport const chunkArray = (array: any[], size: number) => chunk(array, size)\n\nexport const filtering = (data: [], predicate: string, field: string, value: any) => {\n  return filter(data, Predicate.factory(predicate, field, value))\n}\n\nexport const applyRuleObject = (data, ruleField, ruleValue) => {\n  for (let [predicate, value] of Object.entries(ruleValue)) {\n    data = filtering(data, predicate, ruleField, value)\n  }\n\n  return data\n}\n\nexport const applyRuleValuable = (data, ruleField, ruleValue) => {\n  let fieldable = ruleField.split('_')\n  let predicate = last(fieldable) as string\n  let attr = ruleField.replace(`_${predicate}`, '')\n\n  return filtering(data, predicate, attr, ruleValue)\n}\n","import { applyRuleObject, applyRuleValuable, isPlainObject, chunkArray } from '@/utils'\n\nexport class RecollectArray {\n  static recollect = (data: any[], conditions: object): any[] => {\n    let entries = Object.entries(conditions).flatMap((a) => a)\n    let rules = chunkArray(entries, 2)\n\n    for (let [ruleField, ruleValue] of rules) {\n      if (isPlainObject(ruleValue)) {\n        data = applyRuleObject(data, ruleField, ruleValue)\n      } else {\n        data = applyRuleValuable(data, ruleField, conditions[ruleField as string])\n      }\n    }\n\n    return data\n  }\n\n  static filter(data: any[], conditions: object): any[] {\n    let clone = Array.from(data)\n    clone = this.recollect(clone, conditions)\n\n    return clone\n  }\n}\n\nexport default RecollectArray\n"],"names":["equals","data","field","value","get","contains","target","match","String","startsWith","replace","endsWith","includes","Predicate","static","predicate","this","PREDICATES","isFunction","flags","undefined","NaN","length","RegExp","test","regex","flatMap","o","some","matches","not_in","in","exists","Number","filtering","filter","factory","applyRuleObject","ruleField","ruleValue","Object","entries","applyRuleValuable","fieldable","split","last","attr","RecollectArray","conditions","clone","Array","from","recollect","a","rules","chunk","isPlainObject"],"mappings":"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"}